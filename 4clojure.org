
#+TITLE: 4Clojure
#+CREATED: 2020-05-28
#+ROAM_ALIAS:
#+ROAM_TAGS: clojure

Annotated solutions to 4Clojure's [[file:clojure.org][Clojure]] problems.

* 1. Nothing but the Truth

This is a clojure form. Enter a value which will make the form evaluate to true.

#+BEGIN_SRC clojure
(defn nothing-but-truth []
  (= true true))
#+END_SRC
* 2. Simple Math

If you are not familiar with polish notation, simple arithmetic might seem confusing.

#+BEGIN_SRC clojure
(defn simple-math []
  (= (- 10 (* 2 3)) 4))
#+END_SRC
* 3. Intro to strings

Clojure strings are Java strings. This means that you can use any of the Java string methods on Clojure strings.

#+BEGIN_SRC clojure
(defn intro-to-strings []
  (= "HELLO WORLD" (.toUpperCase "hello world")))
#+END_SRC

* 4. Intro to lists

Lists can be constructed with either a function or a quoted form.

#+BEGIN_SRC clojure
(defn intro-to-lists []
    (= (list :a :b :c) '(:a :b :c)))
#+END_SRC

* 5. Lists: conj

When operating on a list, the conj function will return a new list with one or more items "added" to the front.

#+BEGIN_SRC clojure
(defn lists-conj []
  (= '(1 2 3 4) (conj '(2 3 4)))
  (= '(1 2 3 4 (conj '(3 4) 2 1))))
#+END_SRC
* 6. Intro to vectors

Vectors can be constructed several ways. You can compare them with lists.

#+BEGIN_SRC clojure
(defn intro-to-vectors []
  (= [:a :b :c] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c)))
#+END_SRC

* 7. Vectors: conj

When operating on a Vector, the conj function will return a new vector with one or more items "added" to the end.

#+BEGIN_SRC clojure
(defn vectors-conj []
  (= [1 2 3 4] (conj [1 2 3] 4))
  (= [1 2 3 4] (conj [1 2] 3 4)))
#+END_SRC

~conj~ is a clipping, (technically apocope) of conjoin.

* 8. Intro to sets

Sets are collections of unique values.

#+BEGIN_SRC clojure
(defn intro-to-sets []
  (= #{:a :b :c :d} (set '(:a :a :b :c :c :c :c :d :d)))
  (= #{:a :b :c :d} (clojure.set/union #{:a :b :c} #{:b :c :d})))
#+END_SRC

#+BEGIN_QUOTE
In [[file:set-theory.org][set theory]], the union of a collection of sets is the set of all elements in the collection. - [[https://en.wikipedia.org/wiki/Union_(set_theory)][Union (set theory), Wikipedia]]
#+END_QUOTE

In the second example above, there are two sets in the collection.

1. ~#{:a :b :c}~
1. ~#{:b :c :d}~

The union of the sets A and B (A âˆª B) is the set ~#{:a :b :c :d}~.

*Clojure Notes*
- ~=~ returns ~true~ when called as a unary function (with one argument): ~(= 1)~.

* 9. Sets: conj

When operating on a set, the conj function returns a new set with one or more keys "added".

#+BEGIN_SRC clojure
(defn sets-conj []
  (= #{1 2 3 4} (conj #{1 4 3} 2)))

#+END_SRC

* 10. Intro to maps

Maps store key-value pairs. Both maps and keywords can be used as lookup functions. Commas can be used to make maps more readable, but they are not required.

#+BEGIN_SRC clojure
(defn intro-to-maps []
  (= 20 ((hash-map :a 10 :b 20 :c 30) :b))
  (= 20 (:b {:a 10 :b 20 :c 30})))
#+END_SRC

* 19. Last element

- Difficulty: Easy
- Topics: seqs core-functions
- Effort: ðŸ§ 

Write a function which returns the last element in a sequence.

Special Restrictions: last

*Iteration 1*

#+BEGIN_SRC clojure
(defn last-element [s]
  (nth s (- (count s) 1)))
#+END_SRC

*Other solutions*

#+BEGIN_SRC clojure
(defn last-element [s]
  (nth s (dec (count s)))
#+END_SRC

* 20. Penultimate element

- Difficulty: Easy
- Topics: seqs
- Effort: ðŸ§ 

Write a function which returns the second to last element from a sequence.

*Iteration 1*

#+BEGIN_SRC clojure
(defn penultimate-element [s]
  (nth s (- (count s) 2)))
#+END_SRC

*Other solutions*

#+BEGIN_SRC clojure
(defn penultimate-element [s]
  (comp second reverse))
#+END_SRC

* 21. Nth element

- Difficulty: Easy
- Topics: seqs core-functions
- Effort: ðŸ§ 

Write a function which returns the Nth element from a sequence.

Special Restrictions: nth

*Iteration 1*

#+BEGIN_SRC clojure
(defn nth-element [s index]
  (get (vec s) index))
#+END_SRC

*Other solutions*

#+BEGIN_SRC clojure
(defn nth-element [coll n]
  (first (drop n coll)))
#+END_SRC

* 22. Count a sequence

- Difficulty: Easy
- Topics: seqs core-functions
- Effort: ðŸ§ 

Write a function which returns the total number of elements in a sequence.

Special Restrictions: count

*Iteration 1*

#+BEGIN_SRC clojure
(defn count-a-sequence [s]
  (reduce (fn [total item]
            (inc total)) 0 s))
#+END_SRC

*Other solutions*

#+BEGIN_SRC clojure
(defn count-a-sequence [s]
  (reduce + (map (constantly 1) s)))
#+END_SRC

* 23. Reverse a sequence

- Difficulty: Easy
- Topics: seqs core-functions
- Effort: ðŸ§ ðŸ§ ðŸ§ 

Write a function which reverses a sequence.

Special Restrictions: reverse rseq

*Iteration 1*

#+BEGIN_SRC clojure
(defn reverse-a-sequence [s])
#+END_SRC

* 24. Sum it all up

- Difficulty: Easy
- Topics: seqs
- Effort: ðŸ§ 

Write a function which returns the sum of a sequence of numbers.

*Iteration 1*

#+BEGIN_SRC clojure
(defn sum-it-all-up [nums]
  (reduce + nums))
#+END_SRC

* 25. Find the odd numbers

- Difficulty: Easy
- Topics: seqs
- Effort: ðŸ§ 

Write a function which returns only the odd numbers from a sequence.

*Iteration 1*

#+BEGIN_SRC clojure
(defn find-the-odd-numbers [nums]
  (filter odd? nums))
#+END_SRC

* 26. Fibonacci sequence

- Difficulty: Easy
- Topics: Fibonacci seqs
- Effort:

Write a function which returns the first X fibonacci numbers.

*Iteration 1*

* 27. TODO

* 28. Flatten a sequence

- Difficulty: Easy
- Topics: seqs core-functions
- Effort: ðŸ§ ðŸ§ ðŸ§ 

Write a function which flattens a sequence.

Special Restrictions: flatten

*Iteration 1*

#+BEGIN_SRC clojure
(defn my-flatten [coll]
  (seq (reduce (fn [result item]
            (if (coll? item)
                (into result (my-flatten (first (list item))))
                (conj result item)))
          []
          coll)))
#+END_SRC

*Iteration 2*

#+BEGIN_SRC clojure
(defn my-flatten [item]
  (cond
    (coll? item) (mapcat my-flatten item)
    :else [item]))
#+END_SRC
